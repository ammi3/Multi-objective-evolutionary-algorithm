'''
Lin. X, Wang. Y, Xie. Q et al. Task Scheduling with Dynamic Voltage and Frequency Scaling
for Energy Minimization in the MEC Environment. IEEE Transaction on Services Computing, 2015.
'''
import random, copy, math, turtle, os
from Tool import myRandom, myFileOperator
import matplotlib.pyplot as plt
import numpy as np
from queue import Queue


class DVFSA:
    def __init__(self, taskNumber):
        # The information of workflow
        # self.DAG = {1:[2, 3, 4, 5, 6], 2:[8, 9], 3:[7], 4:[8, 9], 5:[9], 6:[8], 7:[10], 8:[10], 9:[10], 10:[]}

        self.DAG, self.taskExeTimeOnCore = self.getWorkflow(taskNumber)


        self.N = taskNumber
        self.precursorNode = self.getPrecursorNode(self.DAG)  #Get the precursors each node
        # {1: [], 2: [1], 3: [1], 4: [1], 5: [1], 6: [1], 7: [3], 8: [2, 4, 6], 9: [2, 4, 5], 10: [7, 8, 9]}

        # The relationship between workflow and mobile device, please refer to Fig.1 in detail.
        # self.taskExeTimeOnCore = {1:[9,7,5], 2:[8,7,6], 3:[6,5,4], 4:[7,5,3], 5:[5,4,2],
        #                           6:[7,6,4], 7:[8,5,3], 8:[6,4,2], 9:[5,3,2], 10:[7,4,2]}
        self.coreTP = {1:[0], 2:[0], 3:[0]} # Index is core number, its element denotes the current time point on the core.
        self.wsTP = [0]    # The current time point on the wireless sending channel.
        self.cloudTP = [0] # The current time point on the cloud.
        self.wrTP = [0]    # The current time point on the wireless receiving channel.
        self.coreEnergy = {1:1, 2:2, 3:4}   # The power consumption Pk values of the three cores under the maximum operating frequency.
        self.T_max = 27 # The Maximum application completion time.
        self.Ps = 0.5 # The power consumption of the RF components.
        self.a = [0.2, 0.5, 0.8, 1]  # The frequency scaling factors
        self.M = self.a.__len__()    # M different frequency levels.

        self.oriSchedule = Schedule()
        self.T_total = None
        self.E_total = 0
        self.taskSet = {} # Index is task id.
        self.initializeTaskSet()
        self.newScheduleSet = [] # It is generated by task migration algorithm.

        self.objectNumber = 2
        self.F_rank = []
        self.EP = []



    def run(self):
        self.stepOne_initialSchedulingAlgorithm()
        self.stepTwo_taskMigrationAlgorithm(self.oriSchedule, self.taskSet)
        self.fast_non_dominated_sort(self.newScheduleSet)
        self.update_EP(self.EP, self.F_rank[1])

        smallestEnergy = copy.deepcopy(self.getSmallestEnergySchedule(self.newScheduleSet))
        count = 0
        while True:
            count += 1
            self.newScheduleSet.clear()
            self.stepTwo_taskMigrationAlgorithm(smallestEnergy, smallestEnergy.taskSet)
            self.fast_non_dominated_sort(self.newScheduleSet)
            self.update_EP(self.EP, self.F_rank[1])

            temp_smallestEnergy = copy.deepcopy(self.getSmallestEnergySchedule(self.newScheduleSet))
            if temp_smallestEnergy != None:
                if temp_smallestEnergy.E_total > smallestEnergy.E_total:
                    break
                else:
                    smallestEnergy = temp_smallestEnergy
            else:
                break

        for ep in self.EP:
            ep.temp_fitness = ep.fitness[0]
        test_fast = sorted(self.EP, key=lambda Individual: Individual.temp_fitness)
        self.printPopulationFitness(test_fast)
        EP_list = [copy.deepcopy(ind.fitness) for ind in test_fast]
        return EP_list  # 返回最终的非支配解集

        # self.StepThree_DVFSAlgorithm(smallestEnergy)


    def update_EP(self, EP, F_rank):  #用当前代的非支配排序后的第一层的非支配解来更新EP
        if(EP == []):
            for ind in F_rank:
                if self.isExist(ind, EP) == False:
                    EP.append(ind)


        else:
            for ind in F_rank:
                if(self.isExist(ind, EP) == False):                 # 先判断ind是否在EP中，若在，则返回True。
                    if(self.isEP_Dominated_ind(ind, EP) == False):  # 然后再判断EP是否支配ind
                        i = 0
                        while(i<EP.__len__()):  #判断ind是否支配EP中的非支配解，若支配，则删除它所支配的解
                            if (self.isDominated(ind.fitness, EP[i].fitness) == True):
                                EP.remove(EP[i])
                                i -= 1
                            i += 1
                        EP.append(ind)


    def isExist(self, ind, EP):   #判断个体ind的适应度是否与EP中某个个体的适应度相对，若相等，则返回True
        for ep in EP:
            if ind.fitness == ep.fitness: # 判断两个列表对应元素的值是否相等
                return True
        return False


    def isEP_Dominated_ind(self, ind, EP):  # 判断EP中的某个个体是否支配ind，若支配，则返回True
        for ep in EP:
            if self.isDominated(ep.fitness, ind.fitness):
                return True
        return False


    def getSmallestEnergySchedule(self, newScheduleSet):
        if self.newScheduleSet != []:
            newScheduleSet = sorted(newScheduleSet, key=lambda Schedule: Schedule.E_total)
            return newScheduleSet[0]


    def calculateScheduleEnergy(self, schedule):
        schedule.E_total = 0
        for taskId in schedule.taskSet:
            schedule.E_total += schedule.taskSet[taskId].energy


    def initializeTaskSet(self):
        for id in self.DAG:
            task = Task()
            task.id = id
            i = 1
            for coreTime in self.taskExeTimeOnCore[id]:
                task.taskExeTimeOnCore[i] = coreTime
                i += 1
            self.taskSet[id] = task
        for id in self.taskSet:
            task = self.taskSet[id]
            for id1 in self.DAG[id]:
                task.sucTaskSet.append(self.taskSet[id1])
            for id2 in self.precursorNode[id]:
                task.preTaskSet.append(self.taskSet[id2])


    def stepOne_initialSchedulingAlgorithm(self):
        self.primaryAssignment()
        self.taskPrioritization()
        self.executionUnitSelection()


    def stepTwo_taskMigrationAlgorithm(self, oriSchedule, taskSet):
        for core_ori in oriSchedule.S:
            if core_ori != 0: # It is not cloud task.
                s_ori = copy.deepcopy(oriSchedule.S[core_ori])
                while s_ori != []:
                    for core_tar in oriSchedule.S:
                        if core_ori != core_tar:
                            new_schedule = Schedule()
                            new_schedule.taskSet = copy.deepcopy(taskSet)
                            new_schedule.S = copy.deepcopy(oriSchedule.S)
                            self.reInitializeTaskSet(new_schedule.taskSet)
                            self.kernelAlgorithm(s_ori[0], core_ori, core_tar,new_schedule)
                            new_schedule.fitness.append(new_schedule.T_total)
                            new_schedule.fitness.append(new_schedule.E_total)
                            self.newScheduleSet.append(new_schedule)


                    s_ori.pop(0)


    def printNewSchedule(self, new_schedule):
        print("S_new--", new_schedule.S)
        for coreId in new_schedule.S:
            if coreId != 0:
                print("core", coreId, ": ",end="")
                for taskId in new_schedule.S[coreId]:
                    task = new_schedule.taskSet[taskId]
                    print(str(taskId)+"=("+str(task.ST_i_l)+","+str(task.FT_i_l)+") ", end="")
                print("\n")

        for coreId in new_schedule.S:
            if coreId == 0:
                print("WS:      ", end="")
                for taskId in new_schedule.S[coreId]:
                    task = new_schedule.taskSet[taskId]
                    print(str(taskId)+"=("+str(task.ST_i_ws)+","+str(task.FT_i_ws)+") ", end="")
                break
        print("\n")

        for coreId in new_schedule.S:
            if coreId == 0:
                print("Cloud:   ", end="")
                for taskId in new_schedule.S[coreId]:
                    task = new_schedule.taskSet[taskId]
                    print(str(taskId) + "=(" + str(task.ST_i_c) + "," + str(task.FT_i_c) + ") ",end="")
                break
        print("\n")

        for coreId in new_schedule.S:
            if coreId == 0:
                print("WR:      ", end="")
                for taskId in new_schedule.S[coreId]:
                    task = new_schedule.taskSet[taskId]
                    print(str(taskId) + "=(" + str(task.ST_i_wr) + "," + str(task.FT_i_wr) + ") ",end="")
                break
        print("\n")
        print("(Time, Energy)=",new_schedule.fitness)
        print("\n\n")


    def primaryAssignment(self):
        for id in self.taskSet:
            task = self.taskSet[id]
            temp = []
            for index in task.taskExeTimeOnCore:
                temp.append(task.taskExeTimeOnCore[index])
            task.T_i_lmin = min(temp)
            task.T_i_re = task.T_i_s + task.T_i_c + task.T_i_r
            if task.T_i_re < task.T_i_lmin:
                task.isPrimaryCloudTask = True
            else:
                task.isPrimaryCloudTask = False


    def taskPrioritization(self):
        # Calculate the computation cost wi for each task
        for id in self.taskSet:
            task = self.taskSet[id]
            if task.isPrimaryCloudTask == True:
                task.w_i = task.T_i_re
            else:
                temp = []
                for index in task.taskExeTimeOnCore:
                    temp.append(task.taskExeTimeOnCore[index])
                task.w_i = np.mean(temp)
        # Calculate the priority level of each task vi
        temp_DAG = copy.deepcopy(self.DAG)
        noneSuccessorNodeSet = self.getNoneSuccessorNodeSet(temp_DAG)
        while noneSuccessorNodeSet != []:
            for id in noneSuccessorNodeSet:
                if id == self.exitTask:
                    self.taskSet[id].priority = self.taskSet[id].w_i
                    temp_DAG.pop(id)
                else:
                    idSucPrioritySet = []
                    for task in self.taskSet[id].sucTaskSet:
                        idSucPrioritySet.append(task.priority)
                    self.taskSet[id].priority = self.taskSet[id].w_i + max(idSucPrioritySet)
                    temp_DAG.pop(id)
            for id1 in noneSuccessorNodeSet:
                for id2 in temp_DAG:
                    if id1 in temp_DAG[id2]:
                        temp_DAG[id2].remove(id1)

            noneSuccessorNodeSet = self.getNoneSuccessorNodeSet(temp_DAG)


    def executionUnitSelection(self):
        temp_taskSet = []
        for id in self.taskSet:
            temp_taskSet.append(self.taskSet[id]) # The same operation for temp_taskSet and self.taskSet.
        temp_taskSet = sorted(temp_taskSet, key=lambda Task: Task.priority, reverse=True)
        for task in temp_taskSet:
            if task.isPrimaryCloudTask == True: # Task vi is a primary cloud task.
                task.islocal = False
                task.RT_i_l = task.ST_i_l = task.FT_i_l = 0.0
                if task.id == self.entryTask:   # Task vi is the entry task.
                    task.RT_i_ws = task.ST_i_ws = 0.0
                    task.FT_i_ws = task.T_i_s
                    task.RT_i_c = task.ST_i_c = task.FT_i_ws
                    task.FT_i_c = task.ST_i_c + task.T_i_c
                    task.RT_i_wr = task.ST_i_wr = task.FT_i_c
                    task.FT_i_wr = task.ST_i_wr + task.T_i_r
                    self.wsTP.append(task.FT_i_ws)
                    self.cloudTP.append(task.FT_i_c)
                    self.wrTP.append(task.FT_i_wr)
                else:
                    task.RT_i_ws = self.get_RT_i_ws(task)
                    task.ST_i_l = float("inf")
                    task.FT_i_l = float("inf")
                    if self.wsTP[-1] < task.RT_i_ws:
                        task.ST_i_ws = task.RT_i_ws
                        task.FT_i_ws = task.ST_i_ws + task.T_i_s
                    else:
                        task.ST_i_ws = self.wsTP[-1]
                        task.FT_i_ws = task.ST_i_ws + task.T_i_s
                    self.wsTP.append(task.FT_i_ws)

                    task.RT_i_c = self.get_RT_i_c(task)
                    if self.cloudTP[-1] < task.RT_i_c:
                        task.ST_i_c = task.RT_i_c
                        task.FT_i_c = task.ST_i_c + task.T_i_c
                    else:
                        task.ST_i_c = self.cloudTP[-1]
                        task.FT_i_c = task.ST_i_c + task.T_i_c
                    self.cloudTP.append(task.FT_i_c)

                    task.RT_i_wr = task.FT_i_c
                    if self.wrTP[-1] < task.RT_i_wr:
                        task.ST_i_wr = task.RT_i_wr
                        task.FT_i_wr = task.ST_i_wr + task.T_i_r
                    else:
                        task.ST_i_wr = self.wrTP[-1]
                        task.FT_i_wr = task.ST_i_wr + task.T_i_r
                    self.wrTP.append(task.FT_i_wr)
                task.energy = self.Ps*(task.FT_i_ws - task.ST_i_ws)
                self.oriSchedule.E_total += task.energy
                self.oriSchedule.S[0].append(task.id)


            else: # Task vi is not a primary cloud task, it may be scheduled on a local core.
                task.islocal = True
                task.RT_i_ws = task.RT_i_c = task.RT_i_wr = 0.0
                task.ST_i_ws = task.ST_i_c = task.ST_i_wr = 0.0
                task.FT_i_ws = task.FT_i_c = task.FT_i_wr = 0.0
                if task.id == self.entryTask:   # Task vi is the entry task.
                    task.RT_i_l = 0
                    task.ST_i_l = 0
                    task.FT_i_l = task.ST_i_l + task.T_i_lmin
                    self.coreTP[3].append(task.FT_i_l)
                    task.coreIndex = 3   # The entry task is executed on 3-th core with minimum finish time.
                else:
                    task.RT_i_l = self.get_RT_i_l(task)
                    task.ST_i_l = float("inf")
                    task.FT_i_l = float("inf")
                    for coreId in self.coreTP:
                        if self.coreTP[coreId][-1] < task.RT_i_l:
                            if task.FT_i_l > (task.RT_i_l + task.taskExeTimeOnCore[coreId]):
                                task.FT_i_l = task.RT_i_l + task.taskExeTimeOnCore[coreId]
                                task.ST_i_l = task.RT_i_l
                                task.coreIndex = coreId
                        else:# >=
                            if task.FT_i_l > (self.coreTP[coreId][-1] + task.taskExeTimeOnCore[coreId]):
                                task.FT_i_l = self.coreTP[coreId][-1] + task.taskExeTimeOnCore[coreId]
                                task.ST_i_l = self.coreTP[coreId][-1]
                                task.coreIndex = coreId
                    self.coreTP[task.coreIndex].append(task.FT_i_l)
                task.energy = self.coreEnergy[task.coreIndex] * (task.FT_i_l - task.ST_i_l)
                self.oriSchedule.E_total += task.energy
                self.oriSchedule.S[task.coreIndex].append(task.id)

        if temp_taskSet[-1].islocal == True:
            self.oriSchedule.T_total = temp_taskSet[-1].FT_i_l
        else:
            self.oriSchedule.T_total = temp_taskSet[-1].FT_i_wr


    def kernelAlgorithm(self, v_tar, core_ori, core_tar, new_schedule):
        S_new = new_schedule.S
        #-------------------------------Insert a task into a certain core--------------------------
        s_tar = S_new[core_tar]
        flag = -1
        if core_tar > 0:  # The migration target is local core.
            v_tar_RT = self.get_RT_i_l(new_schedule.taskSet[v_tar])
            for i in range(s_tar.__len__()):
                if new_schedule.taskSet[s_tar[i]].ST_i_l >= v_tar_RT:
                    s_tar.insert(i, v_tar)
                    flag = 0
                    break
        else:  # The migration target is cloud.
            v_tar_RT = self.get_RT_i_ws(new_schedule.taskSet[v_tar])
            for i in range(s_tar.__len__()):
                if new_schedule.taskSet[s_tar[i]].ST_i_ws >= v_tar_RT:
                    s_tar.insert(i, v_tar)
                    flag = 0
                    break
        if flag == -1:  # v_tar_RT is larger than the every element of new_schedule.taskSet[s_tar[i]].ST_i_ws
            s_tar.append(v_tar)
        S_new[core_ori].remove(v_tar)
        # -------------------------------Insert a task into a certain core--------------------------
        # -------------------------------Initialize vector ready1 and ready2--------------------------
        ready1 = {1: 0} # Index is task id.
        ready2 = {1: 0} # ready2i=0, if all the tasks before task vi in the same sequence Sknew have already been scheduled, otherwise, ready2i=1.

        for taskId in self.DAG: # Initialize ready1.
            if taskId != self.entryTask:
                ready1[taskId] = new_schedule.taskSet[taskId].preTaskSet.__len__()
        for coreId in S_new:    # Initialize ready2.
            if S_new[coreId].__len__() == 1:
                ready2[S_new[coreId][0]] = 0
            else:
                for taskId in S_new[coreId]:
                    ready2[taskId] = 1
        ready2[self.entryTask] = 0
        LIFO_stack = Queue()
        LIFO_stack.put(self.entryTask)
        # -------------------------------Initialize vector ready1 and ready2--------------------------
        # -------------------------------Find a new schedule--------------------------
        while LIFO_stack.empty() != True:
            taskId = LIFO_stack.get()
            for coreId in S_new:
                if taskId in S_new[coreId]:
                    self.rescheduleTask(new_schedule.taskSet[taskId], coreId, new_schedule)
                    new_schedule.taskSet[taskId].isSchedule = True
            self.delete_ready1_ready2_with0(ready1, ready2)
            self.update_ready1_ready2(taskId, S_new, ready1, ready2, new_schedule.taskSet)
            for i in ready1:
                if ready1[i] == 0 and ready2[i] == 0:
                    LIFO_stack.put(i)


    def reInitializeTaskSet(self, taskSet):
        for taskId in self.taskSet:
            taskSet[taskId].isSchedule = False
            # task = taskSet[taskId]
            # task.RT_i_l = task.ST_i_ws = task.FT_i_c = None
            # task.RT_i_ws = task.ST_i_ws = task.FT_i_ws = None
            # task.RT_i_c = task.ST_i_c = task.FT_i_c = None
            # task.RT_i_wr = task.ST_i_wr = task.FT_i_wr = None


    def delete_ready1_ready2_with0(self, ready1, ready2):
        for i in self.DAG:
            if i in ready1.keys():
                if ready1[i] == 0 and ready2[i] == 0:
                    ready1.pop(i)
                    ready2.pop(i)


    def update_ready1_ready2(self, taskId, S_new, ready1, ready2, taskSet):
        for suc_task in taskSet[taskId].sucTaskSet:
            ready1[suc_task.id] -= 1
        for taskId in ready2:
            for coreId in S_new:
                if taskId in S_new[coreId]:
                    if S_new[coreId].__len__() > 1:
                        flag = 0
                        for j in range(0, S_new[coreId].index(taskId)):
                            if taskSet[S_new[coreId][j]].isSchedule == True:
                                flag += 1
                            else:
                                break
                        if flag == S_new[coreId].index(taskId):
                            ready2[taskId] = 0
                    break


    def rescheduleTask(self, task, coreId, new_schedule):
        if coreId == 0:  # Task vi is a cloud task.
            task.islocal = False
            task.RT_i_l = task.ST_i_l = task.FT_i_l = 0.0
            if task.id == self.entryTask:  # Task vi is the entry task.
                task.RT_i_ws = task.ST_i_ws = 0.0
                task.FT_i_ws = task.T_i_s
                task.RT_i_c = task.ST_i_c = task.FT_i_ws
                task.FT_i_c = task.ST_i_c + task.T_i_c
                task.RT_i_wr = task.ST_i_wr = task.FT_i_c
                task.FT_i_wr = task.ST_i_wr + task.T_i_r
                new_schedule.wsTP.append(task.FT_i_ws)
                new_schedule.cloudTP.append(task.FT_i_c)
                new_schedule.wrTP.append(task.FT_i_wr)
            else:
                task.RT_i_ws = self.get_RT_i_ws(task)
                task.ST_i_l = float("inf")
                task.FT_i_l = float("inf")
                if new_schedule.wsTP[-1] < task.RT_i_ws:
                    task.ST_i_ws = task.RT_i_ws
                    task.FT_i_ws = task.ST_i_ws + task.T_i_s
                else:
                    task.ST_i_ws = new_schedule.wsTP[-1]
                    task.FT_i_ws = task.ST_i_ws + task.T_i_s
                new_schedule.wsTP.append(task.FT_i_ws)

                task.RT_i_c = self.get_RT_i_c(task)
                if new_schedule.cloudTP[-1] < task.RT_i_c:
                    task.ST_i_c = task.RT_i_c
                    task.FT_i_c = task.ST_i_c + task.T_i_c
                else:
                    task.ST_i_c = new_schedule.cloudTP[-1]
                    task.FT_i_c = task.ST_i_c + task.T_i_c
                new_schedule.cloudTP.append(task.FT_i_c)

                task.RT_i_wr = task.FT_i_c
                if new_schedule.wrTP[-1] < task.RT_i_wr:
                    task.ST_i_wr = task.RT_i_wr
                    task.FT_i_wr = task.ST_i_wr + task.T_i_r
                else:
                    task.ST_i_wr = new_schedule.wrTP[-1]
                    task.FT_i_wr = task.ST_i_wr + task.T_i_r
                new_schedule.wrTP.append(task.FT_i_wr)
            task.energy = self.Ps * (task.FT_i_ws - task.ST_i_ws)
            new_schedule.E_total += task.energy

        else:  # Task vi is not a cloud task, it may be scheduled on a local core.
            task.islocal = True
            task.RT_i_ws = task.RT_i_c = task.RT_i_wr = 0.0
            task.ST_i_ws = task.ST_i_c = task.ST_i_wr = 0.0
            task.FT_i_ws = task.FT_i_c = task.FT_i_wr = 0.0
            if task.id == self.entryTask:  # Task vi is the entry task.
                task.RT_i_l = 0
                task.ST_i_l = 0
                task.FT_i_l = task.ST_i_l + task.taskExeTimeOnCore[coreId]
            else:
                task.RT_i_l = self.get_RT_i_l(task)
                if task.RT_i_l > new_schedule.coreTP[coreId][-1]:
                    task.ST_i_l = task.RT_i_l
                else:
                    task.ST_i_l = new_schedule.coreTP[coreId][-1]
                task.FT_i_l = task.ST_i_l + task.taskExeTimeOnCore[coreId]
            task.coreIndex = coreId
            new_schedule.coreTP[task.coreIndex].append(task.FT_i_l)
            task.energy = self.coreEnergy[task.coreIndex] * (task.FT_i_l - task.ST_i_l)
            new_schedule.E_total += task.energy
        if new_schedule.taskSet[self.exitTask].islocal == True:
            new_schedule.T_total = new_schedule.taskSet[self.exitTask].FT_i_l
        else:
            new_schedule.T_total = new_schedule.taskSet[self.exitTask].FT_i_wr


    def StepThree_DVFSAlgorithm(self, Schedule):
        for coreId in Schedule.S:
            if coreId > 0 and Schedule.S[coreId] != []:
                for i in range(len(Schedule.S[coreId])):
                    taskId = Schedule.S[coreId][i]
                    vi = Schedule.taskSet[taskId]
                    flag = 0
                    m = 1
                    while flag == 0 and m < self.M:
                        FT_i_new = self.calculateNewFinishTime(m, vi)
                        if i != (len(Schedule.S[coreId]) - 1):  # There is next task v_j on the same core
                            vj = Schedule.taskSet[Schedule.S[coreId][i+1]]
                            lim1 = vj.ST_i_l
                        else:
                            lim1 = self.T_max
                        if vi.id != self.exitTask:
                            lim2 = self.get_min_Succ_ST(vi)
                        else:
                            lim2 = self.T_max
                        if FT_i_new <= lim1 and FT_i_new <= lim2:
                            flag = 1
                            vi.actual_aki = m
                            vi.FT_i_l = FT_i_new
                            Schedule.E_total = Schedule.E_total - vi.energy
                            vi.energy = self.a[vi.actual_aki-1] * vi.energy
                            Schedule.E_total = Schedule.E_total + vi.energy
                            Schedule.fitness[1] = Schedule.E_total
                            break
                        m += 1



    def calculateNewFinishTime(self, m, task):
        FT_i_new = task.ST_i_l + task.taskExeTimeOnCore[task.coreIndex] / self.a[m-1]
        return FT_i_new


    def get_min_Succ_ST(self, task):
        minST = []
        for succ in task.sucTaskSet:
            if succ.islocal == True:
                minST.append(succ.ST_i_l)
            else:
                minST.append(succ.ST_i_ws)
        return min(minST)


    def get_RT_i_l(self, task):
        if task.id == self.entryTask:
            return 0.0
        else:
            pre_max = []
            for pre_task in task.preTaskSet:
                if pre_task.islocal == True:
                    pre_max.append(pre_task.FT_i_l)
                else:
                    pre_max.append(pre_task.FT_i_wr)
            return max(pre_max)


    def get_RT_i_ws(self, task):
        if task.id == self.entryTask:
            return 0.0
        else:
            pre_max = []
            for pre_task in task.preTaskSet:
                if pre_task.islocal == True:
                    pre_max.append(pre_task.FT_i_l)
                else:
                    pre_max.append(pre_task.FT_i_ws)
            return max(pre_max)


    def get_RT_i_c(self, task):
        pre_max = []
        for pre_task in task.preTaskSet:
            pre_max.append(pre_task.FT_i_c)
        return max(task.FT_i_ws, max(pre_max))







    def getNoneSuccessorNodeSet(self, DAG):   # Get node set without successor
        noneSuccessorNodeSet = []
        for id in DAG:
            if DAG[id] == []:
                noneSuccessorNodeSet.append(id)
        return noneSuccessorNodeSet




    def getPrecursorNode(self, DAG):  # Return precursors of each node
        formerNode = {}
        for node in DAG:
            former = []
            for index in DAG:
                if (node in DAG[index]):
                    former.append(index)
            formerNode[node] = former
        return formerNode


    def isDominated(self, fitness_1, fitness_2):  # 前者是否支配后者
        flag = -1
        for i in range(self.objectNumber):
            if fitness_1[i] < fitness_2[i]:
                flag = 0
            if fitness_1[i] > fitness_2[i]:
                return False
        if flag == 0:
            return True
        else:
            return False


    def fast_non_dominated_sort(self, population):
        for p in population:
            p.S_p = []
            p.rank = None
            p.n = 0

        self.F_rank = []
        F1 = []  # 第一个非支配解集前端
        self.F_rank.append(None)
        for p in population:
            for q in population:
                if self.isDominated(p.fitness, q.fitness):
                    p.S_p.append(q)
                elif self.isDominated(q.fitness, p.fitness):
                    p.n += 1
            if (p.n == 0):
                p.rank = 1
                F1.append(p)
        self.F_rank.append(F1)

        i = 1
        while (self.F_rank[i] != []):
            Q = []
            for p in self.F_rank[i]:
                for q in p.S_p:
                    q.n -= 1
                    if (q.n == 0):
                        q.rank = i + 1
                        Q.append(q)

            if(Q != []):
                i += 1
                self.F_rank.append(Q)
            else:
                break

    def getWorkflow(self, taskNumber):
        filename = self.getCurrentPath() + "\workflowSet\\t" + str(taskNumber) +".txt"
        DAG = {}
        taskExeTimeOnCore = {}
        with open(filename, 'r') as readFile:
            for line in readFile:
                if line == 'exe. Time Core:\n':
                    id = 1
                    for line in readFile:
                        exeTimeCore = line.splitlines()
                        exeTimeCore = exeTimeCore[0].split(' ')
                        exeTimeCore = [int(etc) for etc in exeTimeCore]
                        taskExeTimeOnCore[id] = exeTimeCore
                        id += 1
                else:
                    s = line.splitlines()
                    s = s[0].split(':')
                    predecessor = s[0]
                    id = s[1]
                    successor = s[2]
                    if predecessor == '':
                        self.entryTask = int(id) + 1
                    if (successor != ''):
                        temp = []
                        successor = successor.split(',')
                        for st in successor:
                            temp.append(int(st)+1)
                        temp.sort()
                        DAG[int(id)+1] = temp
                    else:
                        self.exitTask = int(id) + 1
                        DAG[int(id)+1] = []
        return DAG, taskExeTimeOnCore

    def getCurrentPath(self):
        return os.path.dirname(os.path.realpath(__file__))

    def getProjectPath(self):
        cur_path = os.path.dirname(os.path.realpath(__file__))
        return os.path.join(os.path.dirname(cur_path))

    def printPopulationFitness(self, population):
        for ind in population:
            print('Index:  ', population.index(ind), "--",  ind.fitness)


class Schedule:
    def __init__(self):
        self.taskSet = {}
        self.S = {0:[], 1:[], 2:[], 3:[]} # Record the set of task that is executed certain execution unit selection. eg. S[3]=[v1,v3,v5,v7,v9,v10]
        self.coreTP = {1: [0], 2: [0], 3: [0]}  # Index is core number, its element denotes the current time point on the core.
        self.wsTP = [0]  # The current time point on the wireless sending channel.
        self.cloudTP = [0]  # The current time point on the cloud.
        self.wrTP = [0]  # The current time point on the wireless receiving channel.
        self.fitness = []
        self.T_total = None
        self.E_total = 0
        self.rank = None
        self.S_p = []
        self.n = 0

class Task:
    def __init__(self):
        self.id = None
        self.preTaskSet = []  #The set of predecessor task (element is Task class).
        self.sucTaskSet = []  #The set of successor task (element is Task class).
        self.taskExeTimeOnCore = {} #eg. {1:9, 2:7, 3:5}
        self.P = [1, 2, 4]  # The power consumption Pk values of the three cores under the maximum operating frequency
        self.actual_aki = 1 # The actual frequency scaling factors.
        self.T_i_lmin = None  #The minimum local execution time.
        self.T_i_s = 3
        self.T_i_c = 1
        self.T_i_r = 1
        self.rk = 2
        self.T_i_re = None     # The remote execution time.
        self.isPrimaryCloudTask = None
        self.islocal = None    # Denote the task is executed locally or on cloud.
        self.isSchedule = False
        self.coreIndex = None # if self.islocal=True, it denotes core number, otherwise its value is None.
        self.w_i = None        # The computation cost.
        self.priority = None   # The priority level of each task.

        self.RT_i_l = None     # The ready time of task vi on a local core.
        self.RT_i_ws = None    # The ready time of task vi on the wireless sending channel.
        self.RT_i_c = None     # The ready time of task vi on the cloud.
        self.RT_i_wr = None    # The ready time for the cloud to transmit back the results of task vi

        self.ST_i_l = None     # The start time of task vi on a local core.
        self.ST_i_ws = None    # The start time of task vi on the wireless sending channel.
        self.ST_i_c = None     # The start time of task vi on the cloud.
        self.ST_i_wr = None    # The start time for the cloud to transmit back the results of task vi

        self.FT_i_l = None     # The finish time of task vj on a local core.
        self.FT_i_ws = None    # The finish time of task vj on the wireless sending channel.
        self.FT_i_c = None     # The finish time of task vj on the cloud.
        self.FT_i_wr = None    # The finish time of task vj on the wireless receiving channel.
        self.energy = 0
